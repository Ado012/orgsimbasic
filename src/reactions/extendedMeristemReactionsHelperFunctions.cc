
// Filename     : extendedMeristemReactionsHelperFunctions.cc
// Description  : Helper Functions for extended Meristem sims
// Author(s)    : Al Do (ado012@ucr.edu)
// Created      : June 2019
// Revision     : $Id: grn.cc 669 2016-05-12 08:53:12Z korsbo $
//

#include"baseReaction.h"
#include"extendedMeristemReactionsHelperFunctions.h"
#include"../organism.h"
#include <random> //ADDITION 051517 Currently unusable due to problems with C11
#include <fstream>//ADDITION 051517
#include <stdlib.h>//ADDITION 051517
#include <string> //ADDITION 100218






double Clavata3ActivationMechanisms(int activation, double clv3Creation, double clv3P, int wusMonomer,
                                    int wusDimer, double wusMonomerCoefficient, double wusDimerCoefficient,
                                    int chromoCycle, Compartment &compartment, double polTimeLimit, int crmOrMarkerSwitch)
{

    //Clavata3ActivationMechanisms: Determines Activation based upon a selected strategy.



    //Activation strategies
    if (activation==1)//graded monomer activation/graded dimer repression
    {
        //clv3Creation=clv3P*(wusMonomerCoefficient*wusMonomer-wusDimerCoefficient*wusDimer);
        //alter activation function to make the crm config and not just the wus concentration generated by config play a role in determining clv3 output
        clv3Creation=clv3P*(wusMonomerCoefficient*wusMonomer-wusDimerCoefficient*wusDimer);


        if (clv3Creation < 0)
            clv3Creation=0;
    }
    else if (activation==2)//single monomer activation
    {
        if (wusMonomer>=1)
            clv3Creation=clv3P*5*(wusMonomerCoefficient*1);
    }
    else if (activation==3)//graded monomer activation/ single dimer repression-dimer dominant
    {
        clv3Creation=clv3P*(wusMonomerCoefficient*wusMonomer-wusDimerCoefficient*wusDimer);
        if (clv3Creation < 0)
            clv3Creation=0;
    }
    else if (activation==4) //graded monomer activation
        clv3Creation=clv3P*(wusMonomerCoefficient*wusMonomer);
    else if (activation==5) //monomer/(dimer+1)
        clv3Creation=clv3P*(wusMonomerCoefficient*wusMonomer/((wusDimerCoefficient*wusDimer)+1));

    else if (activation==6)//monomer more than half
    {
        if (wusMonomer>=3)
            clv3Creation=clv3P*(5*wusMonomerCoefficient*wusMonomer);
    }
    else if (activation==7)//single monomer single dimer -dimer dominant
    {
        if (wusMonomer>=1 && wusDimer==0)
            clv3Creation=clv3P*(5*wusMonomerCoefficient*wusMonomer);
    }
    else if (activation==8)//polymerase activation
    {


        if (compartment.polymeraseBindSite[crmOrMarkerSwitch][chromoCycle]==1 && (compartment.rnaPolTimer[crmOrMarkerSwitch][chromoCycle] <= 0))
       {
            clv3Creation=1*clv3P;
        compartment.polymeraseBindSite[crmOrMarkerSwitch][chromoCycle]=0;
        compartment.rnaPolTimer[crmOrMarkerSwitch][chromoCycle]=0;

        //tracking statement
        compartment.polFire +=1;
        }
    }



    return clv3Creation;
}

//Restrict to internal cylinder through multiplication




void CRMProbabilityGenerator(int m4Flag, int crmOrMarkerSwitch, int chromoCycle, probabilitySegment *probabilityMatrix, int *crmOccupancy, int i, double crmActivityCoefficient,
                             double cooptMonEffect, double cooptDimEffect, double geneCRMSiteBindMaxBaseChance, double geneCRMSiteChance_Unbind, double concModifier, int& eventNum,
                             double& probabilityDeltaSum, int HABonusCoopt, int neighborOnlyCoopt, double dimerBindP, double polBaseBindAffinity, Compartment &compartment, double dimerUnbindP,
                             int L1nodimer, int bonusL1MonCoopt, double distanceFromBase)
{

    //1: CRMProbabilityGenerator: For each site calculate event probabilities based on binding constant, site state, concentration, and site's base affinity
    //build a probability matrix to allow for an event to be chosen at each timestep.

    //0->1
    //1->0 1->2
    //2->1
    int neighbors=0;
    int nearNeighbor1 =0;
    int nearNeighbor2 = 0;
    int nearNeighbor1Location = 0;
    int nearNeighbor2Location = 0;
    int neighborsInInterval = 0;
    int cooperative970Bonus=0;
    double cooperativeEffect, eventChance, eventChance2, polBindChance;
    //int *arraysize=crmOccupancy.size();
    int sampArray[5]={crmOccupancy[0],crmOccupancy[1],crmOccupancy[2],crmOccupancy[3],crmOccupancy[4]};
    int chromoCycleBonus=0;

    if (crmOrMarkerSwitch == 1)
        chromoCycleBonus = 2;


//tag the probability segment with the chromosome it is referring to.
    //probabilityMatrix[eventNum].chromosome=chromoCycle; source of probabilityMatrix tagging bug?

    //if site is empty, a binding event can occur
    if (crmOccupancy[i]==0)
    {//calculate chance to bind
        eventChance=crmActivityCoefficient*geneCRMSiteBindMaxBaseChance*concModifier;


        if (eventChance > 0)//set event on probability spectrum
        {
            probabilityMatrix[eventNum].begin=probabilityDeltaSum;
            probabilityDeltaSum +=eventChance;
            probabilityMatrix[eventNum].end=probabilityDeltaSum;
            probabilityMatrix[eventNum].site=i;
            probabilityMatrix[eventNum].action="BIND";
            probabilityMatrix[eventNum].chromosome=chromoCycle;
            eventNum++;


        }


    }



    //if site is monomer occupied, a binding or unbinding event can occur.
    else if (crmOccupancy[i]==1 )
    {//calculate chance to bind
        eventChance= crmActivityCoefficient*geneCRMSiteBindMaxBaseChance*concModifier*dimerBindP;
//if L1nodimer is activated. No dimerization in L1
        if ((eventChance > 0 && L1nodimer == 0) || (eventChance > 0 && L1nodimer == 1 && distanceFromBase < 8.5))
        {//add to probability matrix
            probabilityMatrix[eventNum].begin=probabilityDeltaSum;
            probabilityDeltaSum +=eventChance;
            probabilityMatrix[eventNum].end=probabilityDeltaSum;
            probabilityMatrix[eventNum].site=i;
            probabilityMatrix[eventNum].action="BIND";
            probabilityMatrix[eventNum].chromosome=chromoCycle;

            eventNum++;
        }


        //cooperative effect, neighboring monomers reduce chance of monomer unbinding.

        if (neighborOnlyCoopt==1)
        {
            for (int m=0; m<=4; m++)
            {if (crmOccupancy[m]==1 && m !=i && (m==(i-1) || m==(i+1))) //&& (m==(i-1) || m==(i+1)) neighbor only code
                 neighbors += 1; }

            if (crmOccupancy[1]==1 and m4Flag==1 && (i==0 || i==2)) //if 970 has monomer, give cooperative bonus
                cooperative970Bonus=HABonusCoopt; //neighbor only code  && (i==1 || i==2)
            //added monomeronly coopt 122020


        }

        else if (neighborOnlyCoopt==2)//Betul style cooperativity: Monomer
        {

            if (crmOccupancy[1]==1) //if 970 occupied by monomer, cooperativity is possible
            {

                if (i == 1) //if examined site is 970, look for nearest neighbors
                {
                    for (int m=0; m<=4; m++)
                    {

                        if (crmOccupancy[m]==1 && m != 1)
                            neighbors += 1;

                    }


                }


                else  //otherwise look for bound monomers or dimers in between 970 and occupied site
                {
                neighbors += 1;

                }


            }


        }


        else
        {
            for (int m=0; m<=4; m++)
            {if (crmOccupancy[m]==1 && m !=i) //&& (m==(i-1) || m==(i+1)) neighbor only code
                 neighbors += 1; }
        }

        //if (crmOccupancy[1]==1 and m4Flag==1) //if 970 has monomer, give cooperative bonus
//can it get bonus even if its by itself?
        if (crmOccupancy[1]==1) //bonus cooperativity if 970 is occupied not just 970m4 according to Betul
        cooperative970Bonus=HABonusCoopt; //neighbor only code  && (i==1 || i==2)


        if (crmOccupancy[1]==1 && bonusL1MonCoopt != 0)
            cooperative970Bonus += bonusL1MonCoopt; //neighbor only code  && (i==1 || i==2)



//added monomer only coopt 122020
        //cooperativeEffect = cooptMonEffect*(neighbors+cooperative970Bonus);
        cooperativeEffect = pow(cooptMonEffect,(neighbors+cooperative970Bonus));
        cooperative970Bonus=0;


        //calculate chance to unbind (check that cooperative effect doesn't kick in)
        if (neighbors>0)
        {
            eventChance2=crmActivityCoefficient*geneCRMSiteChance_Unbind*cooperativeEffect;
            //eventChance2=crmActivityCoefficient*(geneCRMSiteChance_Unbind-cooperativeEffect*(geneCRMSiteChance_Unbind));
        }

        else
            eventChance2=crmActivityCoefficient*geneCRMSiteChance_Unbind;

        neighbors=0;
        cooperativeEffect=0; //zero out cooperativeEffect to prevent carry over from other sites


        if (eventChance2 > 0)
        {//add event to probability spectrum
            probabilityMatrix[eventNum].begin=probabilityDeltaSum;
            probabilityDeltaSum += eventChance2;
            probabilityMatrix[eventNum].end=probabilityDeltaSum;
            probabilityMatrix[eventNum].site=i;
            probabilityMatrix[eventNum].action="UNBIND";
            probabilityMatrix[eventNum].chromosome=chromoCycle;

            eventNum++;
        }


        //handle rna polymerase
        if (compartment.polymeraseBindSite[crmOrMarkerSwitch][chromoCycle]==0)
        {
            //Doesn't need specific monomers because probability is automatically increased the more sites are involved
            polBindChance=crmActivityCoefficient*polBaseBindAffinity;
            probabilityMatrix[eventNum].begin=probabilityDeltaSum;
            probabilityDeltaSum +=polBindChance;
            probabilityMatrix[eventNum].end=probabilityDeltaSum;
            probabilityMatrix[eventNum].site=i;
            probabilityMatrix[eventNum].action="POLBIND";
            probabilityMatrix[eventNum].chromosome=chromoCycle;
            eventNum++;
        }

    }

    //if site is dimer occupied, an unbinding event can occur.
    else if (crmOccupancy[i]==2)
    {

        if (neighborOnlyCoopt==1)
        {
            //cooperative effect, neighboring dimers reduce chance of dimer unbinding.
            for (int m=0; m<=4; m++)
            {if (crmOccupancy[m]==2 && m !=i && (m==i-1 || m==i+1)) //&& (m==i-1 || m==i+1) leave out neighbor only cooperativity for now
                 neighbors += 1; }

            //neighbor only code && (i==0 || i==2)
            if (crmOccupancy[1]==2 && m4Flag==1 && (i==0 || i==2)) //if 970 has monomer, give cooperative bonus
                cooperative970Bonus=HABonusCoopt;
        }

        else if (neighborOnlyCoopt==2)//Betul style cooperativity: Dimer
        {

            if (m4Flag==1 && i==1) //m4 gets cooperativity from all other sites.
            {
                for (int m=0; m<=4; m++)
                {
                    if (crmOccupancy[m] == 2 && m != 1)
                        neighbors += 1;
                }

            }


            else //all other sites get cooperativity from nearest neighbor.
            {

                for (int m=0; m<=4; m++)
                {

                    if (m < i) //check left
                    {
                        nearNeighbor1 = crmOccupancy[m];
                        nearNeighbor1Location = m;

                    }

                    else if (m > i && nearNeighbor2 == 0) //check right
                    {
                        nearNeighbor2 = crmOccupancy[m];
                        nearNeighbor2Location = m;
                    }

                }

                if (nearNeighbor1 == 2)
                    neighbors += 1;
                if (nearNeighbor2 == 2)
                    neighbors += 1;
//nearNeighbor1Location condition prevents 970m4 from double cooperating with sites 3-5
                if (m4Flag == 1 && crmOccupancy[1] ==2 && nearNeighbor1Location > 1 ) //970m4 can cooperate with any location
                    neighbors += 1;

            }


        }



        else
        {
            //cooperative effect, neighboring dimers reduce chance of dimer unbinding.
            for (int m=0; m<=4; m++)
            {if (crmOccupancy[m]==2 && m !=i) //&& (m==i-1 || m==i+1) leave out neighbor only cooperativity for now
                 neighbors += 1; }


        }

        //neighbor only code && (i==0 || i==2)
        if (crmOccupancy[1]==2 && m4Flag==1 ) //if 970 has monomer, give cooperative bonus
            cooperative970Bonus=HABonusCoopt;



        cooperativeEffect = pow(cooptDimEffect,(neighbors+cooperative970Bonus));
        //cooperativeEffect = cooptDimEffect*(neighbors+cooperative970Bonus);
        cooperative970Bonus=0;

        if (neighbors>0)
            eventChance=crmActivityCoefficient*geneCRMSiteChance_Unbind*cooperativeEffect*dimerUnbindP;
        //eventChance=crmActivityCoefficient*(geneCRMSiteChance_Unbind-cooperativeEffect*(geneCRMSiteChance_Unbind));
        //eventChance=crmActivityCoefficient*geneCRMSiteChance_Unbind*cooperativeEffect;


        else
            eventChance=crmActivityCoefficient*geneCRMSiteChance_Unbind*dimerUnbindP;

        neighbors=0;


        cooperativeEffect=0; //zero out cooperativeEffect to prevent carry over from other sites


        if (eventChance > 0)
        {//add to probability spectrum
            probabilityMatrix[eventNum].begin=probabilityDeltaSum;
            probabilityDeltaSum += eventChance;
            probabilityMatrix[eventNum].end=probabilityDeltaSum;
            probabilityMatrix[eventNum].site=i;
            probabilityMatrix[eventNum].action="UNBIND";
            probabilityMatrix[eventNum].chromosome=chromoCycle;
            eventNum++;
        }



    }





}







int CRMEventPicker(int site, int eventFlag, std::string action, double eventBegin, double eventEnd,
                   double wusConc, double randvalue2, int eventNum, double crmTimerLength, double &crmSiteActiveTimer,
                   int &crmSite, Compartment &compartment, int chrom, int monFireLimit, int crmOrMarkerSwitch, int polTimeLimit, int unbindLimit)
{

    int monKeepAgeRoll;
    int neighbors = 0;
    int nearNeighbor1 = 0;
    int nearNeighbor2 = 0;
    int neighborsInInterval = 0;

    if (eventBegin < randvalue2 && eventEnd > randvalue2)
    {

        //A binding event
        if (action=="BIND" && wusConc >=1 )
        {crmSite +=1;


            //initialize timer if empty site is bound by monomer, currently a dimer forming does not reset the timer.
         if (crmSite==1)
         {
             crmSiteActiveTimer=crmTimerLength;

             if (crmOrMarkerSwitch==0)
             {
                 compartment.monFireCountDown[chrom][site]=monFireLimit;

                 //calculate monomer neighbors
                 if (site == 1) //if examined site is 970, look for nearest neighbors
                 {
                     for (int m=0; m<=4; m++)
                     {

                         if (compartment.geneCRM[chrom][m]==1 && m != 1)
                             neighbors += 1;

                     }
                 }



                 else if ( compartment.geneCRM[chrom][1] == 1)
                 {

                         neighbors += 1;

                 }


//timer only for monomers with no cooperativity
                 if (neighbors == 0) //if the site is one of the first three at has monomer neighbors. Start a monomer timer
                     compartment.unbindTimer[chrom][site]=unbindLimit;

                 //tracking statement
                 compartment.monTracker +=1;
             }
             else if (crmOrMarkerSwitch==1)
             {
                 compartment.monFireCountDown2[chrom][site]=monFireLimit;
                 compartment.unbindTimer[chrom+2][site]=unbindLimit;
             }


         }

            //if (frozenWUS == 0)//if WUS is frozen have to prevent the crm code from altering it
            //y[compartment.index()][variableIndex(0,0)]=  y[compartment.index()][variableIndex(0,0)]-1; //disable WUS changes during CLV3 evaluation for now
         else if (crmSite==2)
         {

             crmSiteActiveTimer==0;

             //tracking statement
             if (crmOrMarkerSwitch==0)
                 compartment.dimTracker +=1;
         }

         eventFlag=1;
            //if (compartment.index() ==2)
            //std::cerr << "BIND EVENT" << std::endl;
        }
        else if (action=="UNBIND")//an unbinding event
        {
            crmSite -=1;
            crmSiteActiveTimer=0;//check to see if you zero if unbound to monomer
            //zero timer if site is unbound completely
            if (crmSite==0)
            {
                crmSiteActiveTimer=0;

                if (crmOrMarkerSwitch==0)
                {
                    compartment.unbindTimer[chrom][site]=0;
                    compartment.monFireCountDown[chrom][site]=0;
                }

                if (crmOrMarkerSwitch==1)
                {
                    compartment.unbindTimer[chrom+2][site]=0;
                    compartment.monFireCountDown2[chrom][site]=0;
                }

                //if (frozenWUS == 0)
                //  y[compartment.index()][variableIndex(0,0)]=  y[compartment.index()][variableIndex(0,0)]+1; //disable WUS changes during CLV3 evaluation for now
            }

            //if the site converts back to a monomer from a dimer an overcomplicated roll checks
            //to see if a value derived from randvalue2 is even or odd and resets the monomer age
            //based on this
            if (crmSite==1)
            {
                if (1 <= 1/randvalue2)
                    monKeepAgeRoll= (int) randvalue2;
                else if (1 > 1/randvalue2)
                    monKeepAgeRoll= (int) 1/randvalue2;

                if (monKeepAgeRoll % 2 == 0)
                {
                    if (crmOrMarkerSwitch==0)
                    {//Possible Error: reseting fire rate may have been causing problems with generating high wt expression
                        //plus it should be between reverting to old count and a brand new monomer not going to a completely aged one
                        //tracking statement
                        //compartment.averageAge=compartment.monFireCountDown[chrom][site];
                        //compartment.monFireCountDown[chrom][site]=0;
                        //compartment.unbindTimer[chrom][site]=0;
                    }
                    if (crmOrMarkerSwitch==1)
                        compartment.monFireCountDown2[chrom][site]=0;
                    compartment.unbindTimer[chrom+2][site]=0;
                }



            }


            eventFlag=1;

            //if (compartment.index() % 100==0)
            //std::cerr << "UNBIND EVENT" << compartment.index() << std::endl;
        }

        else if (action=="POLBIND")
        {

            if (compartment.monFireCountDown[chrom][site] > 0 && crmOrMarkerSwitch==0)
            {
                compartment.polymeraseBindSite[crmOrMarkerSwitch][chrom]=1;
                compartment.rnaPolTimer[crmOrMarkerSwitch][chrom]=polTimeLimit;
                compartment.monFireCountDown[chrom][site] -= 1;
            }

            if (compartment.monFireCountDown2[chrom][site] > 0 && crmOrMarkerSwitch==1)
            {
                compartment.polymeraseBindSite[crmOrMarkerSwitch][chrom]=1;
                compartment.rnaPolTimer[crmOrMarkerSwitch][chrom]=polTimeLimit;
                compartment.monFireCountDown2[chrom][site] -= 1;
            }

            eventFlag=1;
        }





    }

    //what happens if the random value lands right on a margin?


    return eventFlag;



}



void CRMSummer(int crmSite, int j, double &crmActiveTimer, int &wusMonomer, int &wusDimer, double timeStepIncrement)
{
    if (crmSite==1)
    {


        if (crmActiveTimer > 0) //if monomer timer is active, allow wusMonomer to fire and subtract from timer. Make sure wusMonomer doesn't have any other effects
        {
            wusMonomer +=1;
            //temporarily disable for new polymerase based activation
            //crmActiveTimer=crmActiveTimer-timeStepIncrement;

            if (crmActiveTimer<0)
                crmActiveTimer=0;
        }

    }

    else if (crmSite==2)
        wusDimer +=1;

}


int CRMOccupiedTest(int crmSite)
{
    int occupiedFlag=0;

    if (crmSite==1)
    occupiedFlag=1;

    else if (crmSite==2)
    occupiedFlag=1;

    return occupiedFlag;

}






int TimeStepOverflowHandler(double timeStep, int polTimeLimit, double timeStepOverflow, int crmOrMarkerSwitch,
                           double clv3P, double timeStepRemain, Compartment &compartment, OverFlowResults &overFlowResults1)
{
    //handles the effects of stochastic timestep overflow
    //returns CLV3Creation, timeStepRemain
    //alters compartment.rnaPolTimer, compartment.polymeraseBindSite, compartment.stochastictimeStepOverflow

    double clv3Creation=0;
    int tfI;
    int timerSet[2]= {0,1};


    if (crmOrMarkerSwitch==1)
    {timerSet[0]=2;
    timerSet[1]=3;
    }


    //If stochastic timestepoverflow is larger than ode timestep then the entire
    //rest of the ODE timestep will be skipped. Overflow will be subtracted by 1
    //Timers will be updated
    if (timeStepOverflow >= timeStep)//Do not need to add new activation because that presumably happened in previous timestep?
    {
        compartment.stochasticStepOverflow[crmOrMarkerSwitch]=compartment.stochasticStepOverflow[crmOrMarkerSwitch]-1;
        timeStepRemain=0;//timestep is zeroed out by large overflow

        compartment.previousTimeStep[crmOrMarkerSwitch]=compartment.latestTimeStep[crmOrMarkerSwitch];
        compartment.latestTimeStep[crmOrMarkerSwitch]=1;
        //no need to update timers here since they are handled in timestep generation


        /* This part shouldn't be necessary if timer update is working properly
        //if RNA polymerase timer reaches limit on either chromosome. Fire
        if (compartment.rnaPolTimer[crmOrMarkerSwitch][0] <= 0)
        {
            clv3Creation += 1*clv3P;
        compartment.polymeraseBindSite[crmOrMarkerSwitch][0]=0;
        compartment.rnaPolTimer[crmOrMarkerSwitch][0]=0;

        //tracking statement
        //compartment.polFire++;

        }
        if (compartment.rnaPolTimer[crmOrMarkerSwitch][1]<=0)
        {
            clv3Creation += 1*clv3P;
        compartment.polymeraseBindSite[crmOrMarkerSwitch][1]=0;
        compartment.rnaPolTimer[crmOrMarkerSwitch][1]=0;
        }
        */

    }

    //if timestep overflow is smaller, simply subtract the overflow from the time remaining
    else
    {
        timeStepRemain=timeStepRemain-timeStepOverflow;//should not overflow into the next timestep but might be a good idea to check if overflow is actually carried out
        compartment.stochasticStepOverflow[crmOrMarkerSwitch]=0;
        compartment.previousTimeStep[crmOrMarkerSwitch]=compartment.latestTimeStep[crmOrMarkerSwitch];
        compartment.latestTimeStep[crmOrMarkerSwitch]=timeStepOverflow;

    }


    overFlowResults1.clv3=clv3Creation;
    overFlowResults1.timeStepRemain= timeStepRemain;

    //returns CLV3Activation, newTimestepOverflow, newTimestep

    return 0;
}


double TimeStepGenerator(int crmOrMarkerSwitch, double randvalue1, int polTimeLimit, Compartment &compartment)
{
    //TimeStepGenerator: Generates timestep
    //returns timeStepRemain
    //alters compartment.rnaPolTimer, compartment.unbindTimer
   double timeStepStochastic=0;
    double timeStepIncrement=0;
    double minTimer=0;
    int timers[14]; //one extra space?
    int tgI;
       int timerSet[2]= {0,1};

    if (crmOrMarkerSwitch==1)
       {
       timerSet[0]= 2;
       timerSet[1] = 3;
       }

    compartment.probabilityDeltaSum[crmOrMarkerSwitch]=compartment.probabilityDeltaSum[crmOrMarkerSwitch];//scaling factor ask weitao?
    //stochastic timestep generation
    timeStepStochastic=(1/((compartment.probabilityDeltaSum[crmOrMarkerSwitch]))*log(1/(randvalue1)));


    timers[0]=timeStepStochastic;
    timers[1]=compartment.rnaPolTimer[crmOrMarkerSwitch][0];
    timers[2]=compartment.rnaPolTimer[crmOrMarkerSwitch][0];//Examine later

    for (tgI = 3; tgI <= 7; tgI++)
    timers[tgI]=compartment.unbindTimer[timerSet[0]][tgI-3];

    for (tgI = 8; tgI <= 12; tgI++)
    timers[tgI]=compartment.unbindTimer[timerSet[1]][tgI-8];

minTimer=timers[0];

    for (tgI=0; tgI <=12; tgI++)
    {
    if ((timers[tgI] < minTimer) && (timers[tgI] > 0))
        minTimer = timers[tgI];

    }

    timeStepIncrement = minTimer;



      //update timers
    //update RNA polymerase timer
   //if the timestep overflows into the next. This should be okay because the rnapoltimer is already updating
      //at beginning of timestep.
    if (compartment.polymeraseBindSite[crmOrMarkerSwitch][0]==1)
        compartment.rnaPolTimer[crmOrMarkerSwitch][0] -= timeStepIncrement;
    if (compartment.polymeraseBindSite[crmOrMarkerSwitch][1]==1)
        compartment.rnaPolTimer[crmOrMarkerSwitch][1] -= timeStepIncrement;


    //update monomer unbinding timers
    for (tgI = 0; tgI<=4; tgI++)
    {
        if (crmOrMarkerSwitch==0)
        {
        if (compartment.unbindTimer[timerSet[0]][tgI] > 0 && compartment.geneCRM[0][tgI]==1)
        {
            compartment.unbindTimer[timerSet[0]][tgI] -= timeStepIncrement;
//unbind expired monomers
            if (compartment.unbindTimer[timerSet[0]][tgI] <= 0)
            compartment.geneCRM[timerSet[0]][tgI] = 0;
        }


        if (compartment.unbindTimer[timerSet[1]][tgI] > 0 && compartment.geneCRM[1][tgI]==1)
        {
        compartment.unbindTimer[timerSet[1]][tgI] -= timeStepIncrement;
//unbind expired monomers
         if (compartment.unbindTimer[timerSet[1]][tgI] <= 0)
        compartment.geneCRM[timerSet[1]][tgI] = 0;
        }

        }

        if (crmOrMarkerSwitch==1)
        {
        if (compartment.unbindTimer[timerSet[0]][tgI] > 0 && compartment.geneCRMMarker[0][tgI]==1)
        compartment.unbindTimer[timerSet[0]][tgI] -= timeStepIncrement;

        if (compartment.unbindTimer[timerSet[1]][tgI] > 0 && compartment.geneCRMMarker[1][tgI]==1)
        compartment.unbindTimer[timerSet[1]][tgI] -= timeStepIncrement;
        }


    }

return timeStepIncrement;
}






//ResetProbabilityMatrix(probabilityMatrix)

